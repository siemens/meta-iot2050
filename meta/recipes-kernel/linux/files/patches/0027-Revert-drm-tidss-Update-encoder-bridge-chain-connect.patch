From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Chun Jiao Zhao <chunjiao.zhao@siemens.com>
Date: Mon, 24 Nov 2025 16:03:54 +0800
Subject: [PATCH] Revert "drm/tidss: Update encoder/bridge chain connect model"

This reverts commit c932ced6b58524eeb948ff252f6512cd6bcb9d9f.

The reverted commit has compatibility issues with the DP bridge chip
(TC358767) driver, causing blurry display and screen artifacts on DP.

This is a workaround that reverts that commit to avoid the blurry display
and artifacts.

Signed-off-by: Chun Jiao Zhao <chunjiao.zhao@siemens.com>
---
 drivers/gpu/drm/tidss/tidss_encoder.c | 140 ++++++++++----------------
 drivers/gpu/drm/tidss/tidss_encoder.h |   5 +-
 drivers/gpu/drm/tidss/tidss_kms.c     |  12 ++-
 3 files changed, 63 insertions(+), 94 deletions(-)

diff --git a/drivers/gpu/drm/tidss/tidss_encoder.c b/drivers/gpu/drm/tidss/tidss_encoder.c
index 17a86bed8054..0d4865e9c03d 100644
--- a/drivers/gpu/drm/tidss/tidss_encoder.c
+++ b/drivers/gpu/drm/tidss/tidss_encoder.c
@@ -6,125 +6,91 @@

 #include <linux/export.h>

-#include <drm/drm_atomic_helper.h>
-#include <drm/drm_bridge.h>
-#include <drm/drm_bridge_connector.h>
 #include <drm/drm_crtc.h>
 #include <drm/drm_modeset_helper_vtables.h>
 #include <drm/drm_panel.h>
 #include <drm/drm_of.h>
-#include <drm/drm_simple_kms_helper.h>

 #include "tidss_crtc.h"
 #include "tidss_drv.h"
 #include "tidss_encoder.h"

-struct tidss_encoder {
-	struct drm_bridge bridge;
-	struct drm_encoder encoder;
-	struct drm_connector *connector;
-	struct drm_bridge *next_bridge;
-	struct tidss_device *tidss;
-};
-
-static inline struct tidss_encoder
-*bridge_to_tidss_encoder(struct drm_bridge *b)
-{
-	return container_of(b, struct tidss_encoder, bridge);
-}
-
-static int tidss_bridge_attach(struct drm_bridge *bridge,
-			       enum drm_bridge_attach_flags flags)
-{
-	struct tidss_encoder *t_enc = bridge_to_tidss_encoder(bridge);
-
-	return drm_bridge_attach(bridge->encoder, t_enc->next_bridge,
-				 bridge, flags);
-}
-
-static int tidss_bridge_atomic_check(struct drm_bridge *bridge,
-				     struct drm_bridge_state *bridge_state,
-				     struct drm_crtc_state *crtc_state,
-				     struct drm_connector_state *conn_state)
+static int tidss_encoder_atomic_check(struct drm_encoder *encoder,
+				      struct drm_crtc_state *crtc_state,
+				      struct drm_connector_state *conn_state)
 {
-	struct tidss_encoder *t_enc = bridge_to_tidss_encoder(bridge);
-	struct tidss_device *tidss = t_enc->tidss;
+	struct drm_device *ddev = encoder->dev;
 	struct tidss_crtc_state *tcrtc_state = to_tidss_crtc_state(crtc_state);
 	struct drm_display_info *di = &conn_state->connector->display_info;
-	struct drm_bridge_state *next_bridge_state = NULL;
-
-	if (t_enc->next_bridge)
-		next_bridge_state = drm_atomic_get_new_bridge_state(crtc_state->state,
-								    t_enc->next_bridge);
+	struct drm_bridge *bridge;
+	bool bus_flags_set = false;
+
+	dev_dbg(ddev->dev, "%s\n", __func__);
+
+	/*
+	 * Take the bus_flags from the first bridge that defines
+	 * bridge timings, or from the connector's display_info if no
+	 * bridge defines the timings.
+	 */
+	drm_for_each_bridge_in_chain(encoder, bridge) {
+		if (!bridge->timings)
+			continue;
+
+		tcrtc_state->bus_flags = bridge->timings->input_bus_flags;
+		bus_flags_set = true;
+		break;
+	}

-	if (next_bridge_state) {
-		tcrtc_state->bus_flags = next_bridge_state->input_bus_cfg.flags;
-		tcrtc_state->bus_format = next_bridge_state->input_bus_cfg.format;
-	} else if (di->num_bus_formats) {
-		tcrtc_state->bus_format = di->bus_formats[0];
-		tcrtc_state->bus_flags = di->bus_flags;
-	} else {
-		dev_err(tidss->dev, "%s: No bus_formats in connected display\n",
+	if (!di->bus_formats || di->num_bus_formats == 0)  {
+		dev_err(ddev->dev, "%s: No bus_formats in connected display\n",
 			__func__);
 		return -EINVAL;
 	}

+	// XXX any cleaner way to set bus format and flags?
+	tcrtc_state->bus_format = di->bus_formats[0];
+	if (!bus_flags_set)
+		tcrtc_state->bus_flags = di->bus_flags;
+
 	return 0;
 }

-static const struct drm_bridge_funcs tidss_bridge_funcs = {
-	.attach				= tidss_bridge_attach,
-	.atomic_check			= tidss_bridge_atomic_check,
-	.atomic_reset			= drm_atomic_helper_bridge_reset,
-	.atomic_duplicate_state		= drm_atomic_helper_bridge_duplicate_state,
-	.atomic_destroy_state		= drm_atomic_helper_bridge_destroy_state,
+static void tidss_encoder_destroy(struct drm_encoder *encoder)
+{
+	drm_encoder_cleanup(encoder);
+	kfree(encoder);
+}
+
+static const struct drm_encoder_helper_funcs encoder_helper_funcs = {
+	.atomic_check = tidss_encoder_atomic_check,
+};
+
+static const struct drm_encoder_funcs encoder_funcs = {
+	.destroy = tidss_encoder_destroy,
 };

-int tidss_encoder_create(struct tidss_device *tidss,
-			 struct drm_bridge *next_bridge,
-			 u32 encoder_type, u32 possible_crtcs)
+struct drm_encoder *tidss_encoder_create(struct tidss_device *tidss,
+					 u32 encoder_type, u32 possible_crtcs)
 {
-	struct tidss_encoder *t_enc;
 	struct drm_encoder *enc;
-	struct drm_connector *connector;
 	int ret;

-	t_enc = drmm_simple_encoder_alloc(&tidss->ddev, struct tidss_encoder,
-					  encoder, encoder_type);
-	if (IS_ERR(t_enc))
-		return PTR_ERR(t_enc);
-
-	t_enc->tidss = tidss;
-	t_enc->next_bridge = next_bridge;
-	t_enc->bridge.funcs = &tidss_bridge_funcs;
+	enc = kzalloc(sizeof(*enc), GFP_KERNEL);
+	if (!enc)
+		return ERR_PTR(-ENOMEM);

-	enc = &t_enc->encoder;
 	enc->possible_crtcs = possible_crtcs;

-	/* Attaching first bridge to the encoder */
-	ret = drm_bridge_attach(enc, &t_enc->bridge, NULL,
-				DRM_BRIDGE_ATTACH_NO_CONNECTOR);
-	if (ret) {
-		dev_err(tidss->dev, "bridge attach failed: %d\n", ret);
-		return ret;
-	}
-
-	/* Initializing the connector at the end of bridge-chain */
-	connector = drm_bridge_connector_init(&tidss->ddev, enc);
-	if (IS_ERR(connector)) {
-		dev_err(tidss->dev, "bridge_connector create failed\n");
-		return PTR_ERR(connector);
-	}
-
-	ret = drm_connector_attach_encoder(connector, enc);
-	if (ret) {
-		dev_err(tidss->dev, "attaching encoder to connector failed\n");
-		return ret;
+	ret = drm_encoder_init(&tidss->ddev, enc, &encoder_funcs,
+			       encoder_type, NULL);
+	if (ret < 0) {
+		kfree(enc);
+		return ERR_PTR(ret);
 	}

-	t_enc->connector = connector;
+	drm_encoder_helper_add(enc, &encoder_helper_funcs);

 	dev_dbg(tidss->dev, "Encoder create done\n");

-	return ret;
+	return enc;
 }
diff --git a/drivers/gpu/drm/tidss/tidss_encoder.h b/drivers/gpu/drm/tidss/tidss_encoder.h
index 3e561d6b1e83..ace877c0e0fd 100644
--- a/drivers/gpu/drm/tidss/tidss_encoder.h
+++ b/drivers/gpu/drm/tidss/tidss_encoder.h
@@ -11,8 +11,7 @@

 struct tidss_device;

-int tidss_encoder_create(struct tidss_device *tidss,
-			 struct drm_bridge *next_bridge,
-			 u32 encoder_type, u32 possible_crtcs);
+struct drm_encoder *tidss_encoder_create(struct tidss_device *tidss,
+					 u32 encoder_type, u32 possible_crtcs);

 #endif
diff --git a/drivers/gpu/drm/tidss/tidss_kms.c b/drivers/gpu/drm/tidss/tidss_kms.c
index f371518f8697..2f2539dd74f0 100644
--- a/drivers/gpu/drm/tidss/tidss_kms.c
+++ b/drivers/gpu/drm/tidss/tidss_kms.c
@@ -188,6 +188,7 @@ static int tidss_dispc_modeset_init(struct tidss_device *tidss)
 	for (i = 0; i < num_pipes; ++i) {
 		struct tidss_plane *tplane;
 		struct tidss_crtc *tcrtc;
+		struct drm_encoder *enc;
 		u32 hw_plane_id = feat->vid_order[tidss->num_planes];
 		int ret;

@@ -210,13 +211,16 @@ static int tidss_dispc_modeset_init(struct tidss_device *tidss)

 		tidss->crtcs[tidss->num_crtcs++] = &tcrtc->crtc;

-		ret = tidss_encoder_create(tidss, pipes[i].bridge,
-					   pipes[i].enc_type,
+		enc = tidss_encoder_create(tidss, pipes[i].enc_type,
 					   1 << tcrtc->crtc.index);
-		if (ret) {
+		if (IS_ERR(enc)) {
 			dev_err(tidss->dev, "encoder create failed\n");
-			return ret;
+			return PTR_ERR(enc);
 		}
+
+		ret = drm_bridge_attach(enc, pipes[i].bridge, NULL, 0);
+		if (ret)
+			return ret;
 	}

 	/* create overlay planes of the leftover planes */
