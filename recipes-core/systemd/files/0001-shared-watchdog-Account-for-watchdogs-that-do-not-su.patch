From 5a44fefc75f964a2784a5fe4ae7dba7486d6a2e5 Mon Sep 17 00:00:00 2001
From: Jan Kiszka <jan.kiszka@siemens.com>
Date: Thu, 9 Sep 2021 16:36:03 +0200
Subject: [PATCH] shared/watchdog: Account for watchdogs that do not support
 WDIOC_SETTIMEOUT

Not all watchdog drivers support WDIOC_SETTIMEOUT (e.g. rti-wdt). Those
are generally configured upfront, outside of the systemd's control.

Allow driving them as well by checking if the user-configured timeout
is in line with pre-programmed one, skipping the setting if that is the
case. If both values deviate, we continue to program and then also fail
with such watchdogs.

Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
---
 src/shared/watchdog.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/src/shared/watchdog.c b/src/shared/watchdog.c
index d33acafe64..9fce6a4adc 100644
--- a/src/shared/watchdog.c
+++ b/src/shared/watchdog.c
@@ -33,12 +33,15 @@ static int update_timeout(void) {
                         return log_warning_errno(errno, "Failed to disable hardware watchdog: %m");
         } else {
                 char buf[FORMAT_TIMESPAN_MAX];
-                int sec, flags;
+                int sec, current_timeout, flags;
                 usec_t t;
 
+                if (ioctl(watchdog_fd, WDIOC_GETTIMEOUT, &current_timeout) < 0)
+                        current_timeout = -1;
+
                 t = DIV_ROUND_UP(watchdog_timeout, USEC_PER_SEC);
                 sec = (int) t >= INT_MAX ? INT_MAX : t; /* Saturate */
-                if (ioctl(watchdog_fd, WDIOC_SETTIMEOUT, &sec) < 0)
+                if (sec != current_timeout && ioctl(watchdog_fd, WDIOC_SETTIMEOUT, &sec) < 0)
                         return log_warning_errno(errno, "Failed to set timeout to %is: %m", sec);
 
                 watchdog_timeout = (usec_t) sec * USEC_PER_SEC;
-- 
2.31.1

